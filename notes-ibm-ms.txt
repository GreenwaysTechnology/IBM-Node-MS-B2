

Session :

1.ES 6


2.Node


3.Microservices

Javascript
..........

Lab setup:

1.cmd
2.vscode
3.node

/////////////////////////////////////////////////////////////////////////////////////////////

Project Setup:

javascriptapps>mkdir src


Javascript:
..........

What is javascript?

 javascript is pl.

C++ /java is Object oriented programming language.

 Object oriented programming  : it is way of writting.

Ways:
1.Procedural
2.OO
3.Functional Programming.
.........

Now a days many languages follows many ways in one language: hybrid paradigms(ways)

From java 8 , java is not only oo language but also functional style language.


javascript is hybrid pl
 ->Object based Programming
 ->Functional Style Programming
 ->Event driven Programming


Why javascript language was invented?

Brendan Eich is an American technologist and creator of the JavaScript programming language. 

Javascript pl invented at Netscap communication.

Javascript invented for web.

1989-1995 - static web

1996 - dynamic web : CGI,J2EE,ASP,PHP :server side
Netscap invented language at client side for making web dynamic :

Version history
1996 :  mocha 
1996  : action script
1997 :  javascript

The language submmited to committe : ECMA(European Computer Manufacturers Association)

1998 : THE FIrst javascript version : js 1.0 : ES 1.0
1999 : no release 
2000 : es 3.0
2005 : Ajax introduced
2007 : ES 4
2008 : ES 5
2012 : ES 6 proposal made
2015 : ES 6 Final draft
2016 : ES 7
..........................>

Javascript learning path:(ES 5 /ES6)
1.javascript language fundamentals
2.javascript and functions
3.javascript object based programming
4.javascript and networking : ajax
5.javascript browser programming : DOM Programming



1.javascript language fundamentals

->Variables and types,values(literals)
->operators
->loops


PL :  Strongly typed and weakly typed

 data
 type variable=10

java :Strongly typed
  int a =10
  a="hello"

weakly typed : type not verified during compile time
but vertifed during runtime

javascript : weakly typed /no type :

variable declaration

var | let | const | this variableName = value

value is called literal.

Note: based on literal only the type of variable is identified during runtime.

eg;
 var i =10;

here var is keyword
i is variable
10 is literal
 what is type of 10.

10 is number type


How to compile and execute javascript code?

 javascript runtime /engine : It is c /c++ program to compile and run js code.

Types of js engine:

1.Embeded js engine
    -Browser
2.standalone js engine
   -Node js : v8

google : chrome : v8
fire fox : spider monkey
ms : chakra
etc..

Types and variables

1.number
  size : 64 bit : aka double.

2.strings
 strings can be declared
  "" 
  ''
  `` - es 6
 size : each character is 16 bit unicode charater 

3.booleans ; true /false
  size : 1 bit


4.undefined: the variable has not been initalized
 var salary;  //= undefined;
 
 has no size

5.NaN : not  a number 

 1. it is unique no gengered by js engine in order to indicated numerical operations errors.

 2.Nan is toxic : you have to fix this.

When you get NaN?

 1. if you do compuation against undefined variable

 2. Type conversion
     ->String to number conversion.
       "10" - string ---10 number
      Types of conversion :
       1.implicit
          auto conversion
       2.explicit
          using apis : parseInt, parseFloat



6.Infinifty : div /0


other types:

7.function type
8.null
9.Object
////////////////////////////////////////////////////////////////////////////////////////////

let and const over view:

let and const is alternate for var keywords in es 6;

let and const vs var : to be discussed.

let vs const

Points:

1.let and const is used to declare variable :
  code best practice : if you are writing es 6 apps please follow let and const only.


const : 

 1.readonly

//variables and types

var i = 10;
console.log("I " + i);
var firstName ="Subramanian";
var lastName ='Murugan';
console.log("Full Name is " + firstName + " " + lastName);
console.log("Full Name is " , firstName , " " , lastName);
//back tick : use case 1: for simplifiying string concation
console.log(`Full Name ${firstName} ${lastName} `);

//back tick : use case 2: multi line string literal
var htmlDoc = "<html>" +
              "<body>" +
              "<h1>Hello</h1>" + 
              "</body>"+
               "</html>";
console.log(htmlDoc)

var htmlnewDoc =`
   <html>
   <body>
   <h1>Hello</h1>
   </body>
   </html>
`;
console.log(htmlnewDoc)

//booleans
var isWorking =true;
var hasProject =false;

console.log(`isWorking ${isWorking}`);
console.log(`Has Project ${hasProject}`)

//undefined
var salary;
console.log(`The salary is ${salary}`);

//undefined * 100 =NaN
var totalSalary = salary * 100;
console.log(`Total salary is ${totalSalary}`);

//type conversion
var stockValue = "100";
var qty =10;
//implicit conversion  : conversion first and then computation
var totalStock = stockValue * qty;
//explicit conversion : through api
var totalStockValue = parseFloat(stockValue) * qty;
console.log(`Total Stock Value ${totalStock}`)
console.log(`Total Stock Value ${totalStockValue}`)

//while conversion , $ is special character so that NaN 
var wage ="$10"
var totalWage = wage * 100
console.log(`Total Wage Value ${totalWage}`)

//infinity
var avgStock =  1000/ 0;
console.log(`Avg Stock ${avgStock}`)


const and let

//let 

let firstName ='Subramanian';
console.log(`The Name is ${firstName}`)

let a  =100;
console.log(`A value ${a}`);
//re intialization
a =900;
console.log(`A value ${a}`);
a =true
console.log(`A value ${a}`);
a ="hello"
console.log(`A value ${a}`);
const b =100;
console.log(` B value ${b}`);
b =87777;
///////////////////////////////////////////////////////////////////////////////////////////

Operators:

Comparsional operator

1.equal 
 ==
 ===
 !=
 !==

=== operator is recommended operator

== : only value comparsion
=== : value + type comparsion

//operators
//==
let a =100;
let b =100;
let result =  a==b;
console.log(`Equal result  ${result}`)

//this is bug in js language itself.
//the == compares the value portion not type portions
let x = "100" //type of x is string
let y = 100; //type of y is number

//VALE comparsion
let result1= x ==y;
//type + value comparsion : ===
let result2  = x === y;
console.log(` X AND Y result is ${result1}`)
console.log(` X AND Y result is ${result2}`)

//////////////////////////////////////////////////////////////////////////////////////////

or (||):  works based on truth table 


Decision making : if...else, if..else if,switch case, tenary operator ?:

if(boolean expression){

}else{

}

Advanced boolean concepts: Truthy and falsy values:
..................................................


in java only true and false are boolean expressions.

in java

boolean a =true;
if(a){}else{} : valid code.

int a =10;
if(a){}else{} : invalid code

in javascript:
let a =10; //number
if(a){
   console.log('A') 
}else{
    console.log('Not a')
}

let firstName = 'subramanian';
if(firstName){
    console.log('You have firstName')
}else{
    console.log('You have no first name')
}

Which is true and which is false?


 "In javascript every thing is true or truthy" but few values are false or falsy.


Falsy values:

1.boolean false
2.0
3.empty string "",''
4.NaN 
5.undefind
6.null


Tenary operator : for booleans to replace if condtions.


|| operator formula:

let  start;//undefined
let result = start || 100;
console.log(`The result is ${result}`)

if first operand(start) is true,then result would be first operand itself,else second operand



//or

let isWorking = true;
let hasProject = true;
//if
if(isWorking || hasProject){
  console.log('You are in the Company')
}else{
    console.log('You are out of company')
}
//boolean expression

let a =10; //number
if(a){
   console.log('A') 
}else{
    console.log('Not a')
}

let firstName = 'subramanian';
if(firstName){
    console.log('You have firstName')
}else{
    console.log('You have no first name')
}

let counter;
if(counter){
    console.log('counter')
}else{
    console.log('no counter')
}

counter ? console.log('counter-1 ') : console.log('no counter-1')
///////////////////////////////////////////////////////////////////////////////////////////
//operator

let  start;//undefined
let result = start || 100;
console.log(`The result is ${result}`)

let end;
end = end || 1000;
console.log(`The end is ${end}`)

let message="Hello";
let resultMessage =  message || "boom!";
console.log(resultMessage);


&& : operator is similar to or operator but opposit

///////////////////////////////////////////////////////////////////////////////////

! not and !!(invertor)
......................

! will make truthy and falsy values.



//or

let isWorking = true;
let hasProject = true;
//if
if(isWorking || hasProject){
  console.log('You are in the Company')
}else{
    console.log('You are out of company')
}
//boolean expression

let a =10; //number
if(a){
   console.log('A') 
}else{
    console.log('Not a')
}

let firstName = 'subramanian';
if(firstName){
    console.log('You have firstName')
}else{
    console.log('You have no first name')
}

let counter;
if(counter){
    console.log('counter')
}else{
    console.log('no counter')
}

counter ? console.log('counter-1 ') : console.log('no counter-1')
///////////////////////////////////////////////////////////////////////////////////////////
//operator

let  start;//undefined
let result = start || 100;
console.log(`The result is ${result}`)

let end;
end = end || 1000;
console.log(`The end is ${end}`)

let message="Hello";
let resultMessage =  message || "boom!";
console.log(resultMessage);


let shouldbeDone;
console.log(!shouldbeDone)

let done = false;
console.log(!done);
console.log(!!done)
//////////////////////////////////////////////////////////////////////////////////////

Other operators:

1.type of
2.new 
3.instance of
4.for..in
5. "."
6."[]"
7. "..."

typeof operator is used to know the runtime type of a
variable/value

according to type of operator:

number,nan,infinity : number type
string : string
boolean : boolean
undefined: undefined
null,object: object
function : function




//or

let isWorking = true;
let hasProject = true;
//if
if(isWorking || hasProject){
  console.log('You are in the Company')
}else{
    console.log('You are out of company')
}
//boolean expression

let a =10; //number
if(a){
   console.log('A') 
}else{
    console.log('Not a')
}

let firstName = 'subramanian';
if(firstName){
    console.log('You have firstName')
}else{
    console.log('You have no first name')
}

let counter;
if(counter){
    console.log('counter')
}else{
    console.log('no counter')
}

counter ? console.log('counter-1 ') : console.log('no counter-1')
///////////////////////////////////////////////////////////////////////////////////////////
//operator

let  start;//undefined
let result = start || 100;
console.log(`The result is ${result}`)

let end;
end = end || 1000;
console.log(`The end is ${end}`)

let message="Hello";
let resultMessage =  message || "boom!";
console.log(resultMessage);


let shouldbeDone;
console.log(!shouldbeDone)

let done = false;
console.log(!done);
console.log(!!done)

//type of 

let price =100;
let name ="subramanian"
let qty;
let totalPrice = price * qty;
console.log(`The type of price is ${typeof price}`)
console.log(`The type of name is ${typeof name}`)
console.log(`The type of totalPrice is ${typeof totalPrice}`)

///////////////////////////////////////////////////////////////////////////////////////////////

loops:

for,while,do..while :syntax same like c/c++ java

for..in : loop

iterators: each,find,filter.....

for(let i =0;i<10;i++){
    console.log(i)
}
///////////////////////////////////////////////////////////////////////////////////////////

Functions:

logical unit, having logic.

functions are literal in js(values)

function basics:
/funcition declaration
function sayHello(){
    console.log('Hello')
}
//function invocation.
sayHello();

in js function has properties:

return values
args/parameters


//funcition declaration
function sayHello() {
    console.log('Hello')
}
//function invocation.
sayHello();

//parameters and args
//a, and b is args
function add(a, b) {
    let c = a + b;
    console.log(`Add result is ${c}`)
}
//10,10 is parameters
add(10, 10);
//args without values
//solution : 1 es 5 style
/**function multiply(a, b) {
    let c = (a || 1) * (b || 1);
    console.log(`multiply result is ${c}`)
}**/

//es6 style :default args
function multiply(a = 1, b = 1) {
    let c = a * b;
    console.log(`multiply result is ${c}`)
}
multiply(10, 2)
multiply();//without parameters a,b are undefined
multiply(10);//single parameter

//i want function that should take more no of args , but i dont know how many parameters in
//pass in runtime
//variable args : var args : ES 5
/**function logger() {
    console.log(arguments)
}**/
//var args in es 6 : REST OPERATOR 
function logger(...logMessage) {
    console.log(logMessage)
}
logger('hello');
logger('hai', 'hello');
logger('hai', 'hello', 'welcome', 'test')

////////////////////////////////////////////////////////////////////////////////////

function getCounter(){
    return 10;
}
console.log(getCounter());

function substract(a=10,b=10){
  return a - b;
}
console.log(substract(100,10))
console.log(substract())

function login(userName='admin',password='admin'){
   if(userName === 'admin' && password === 'admin'){
       return true;
   }
   return  //false
}
login('guest','guest') ? console.log('login success') : console.log('login failed')

/////////////////////////////////////////////////////////////////////////////////////////////

Function literals : function as literal

Function declaration patterns:


1.function sayHello(){}
  sayHello();

2.function can be assigned to a variable.
  let a =10;

  let b = function as literal

let greeter = function() {
    
};

Formula:

 function can be assigned to a variable.
 once function is assigned to a variable, that variable can be
 used to invoke , pass, return that function: function pointers in c


Anonmous function: funciton without name.
function() {
    
};

function literals : params,args

//pattern 2: ES 5 Style

let greeter = function () {
    console.log('Greeter function');
};
//invoke
greeter();

let add = function (a = 10, b = 10) {
    return a + b;
};
console.log(add(10,10));



//function declarations

//pattern 1

//funcition declaration
function sayHello() {
    console.log('Hello')
}
//function invocation.
sayHello();

//pattern 2: ES 5 Style

let greeter = function () {
    console.log('Greeter function');
};
//invoke
greeter();

let add = function (a = 10, b = 10) {
    return a + b;
};
console.log(add(10,10));
............................................................................................
Arrow functions: lambda syntax:

 ES 6 version function literals.

1.Syntax sugar of existing function literal
2.the function binding: this

let greeter = () => {
    console.log('Greeter function');
};
//invoke
greeter();

//pattern 2: ES 6 Style : arrow function

let greeter = () => {
    console.log('Greeter function');
};
//invoke
greeter();

//arrow syntax features:

//1. if function has only one line of body: Remove {}
let welcome = () => console.log('Welcome function');
welcome();

//2. Parameters and args : multiple parameter with default value

let add = (a = 1, b = 1) => {
    let c = a + b;
    console.log(`Add ${c}`);
};
add();

//3.parameters and args : single parameter without default value : remove ()
let getStock = value => console.log(value);
getStock(100);
//4: return values: if function more line of body

let calcualte = (a=1,b=1)=>{
    let c = a * b;
    return c;
};
console.log(calcualte(10,10));
//5. single arg, no default value, and return the same, no body : remove return statment

let getStatus = loggedIn => loggedIn;

console.log(getStatus(true))

/////////////////////////////////////////////////////////////////////////////////////////

What can be passed as parameter to function?

function myfun(arg){

}

myfun(1) //number
myfun("hello"//string
myfun(true) //boolean
myfun()//undefined

You can pass any literal as a parameter including function.


How to pass function as a parameter?



//funcition
//a =x ,b=y
function add(a, b) {
    return a + b;
}
//values
add(10, 10); //passing values directly
let x = 10;
let y = 20;
add(x, y); // passing values via variables

//caller =welcome = function(){}
function sayGreeter(caller) {
    caller();
}

let welcome = function () {
    console.log('Welcome to javascript!');
};
//passing function via variable
sayGreeter(welcome);

//passing function directly
sayGreeter(function () {
    console.log('Greetings!')
});
///////////////////////////////////////////////////////////////////////////////////////

//Arrow version

const greetMe = caller => caller();

let hai = () => console.log('Welcome to javascript:Arrow Version');
greetMe(hai);

//passing function directly
greetMe(()=>console.log('function arrow Version'))




//caller =welcome = function(){}
function sayGreeter(caller) {
    let result = caller('Hello');
    console.log(result);
}

let welcome = function (message='foo') {
    //console.log(message);
    return message;
};
//passing function via variable
sayGreeter(welcome);

//passing function directly
sayGreeter(function (message='bar') {
    //console.log(message)
    return message;
});
//////////////////////////////////////////////////////////////////////////////////////

const print = caller=>{
    caller('Error Message')
};

let warning = (message='Warning Message')=>console.log(message);
print(warning);

print((message='Warning Message')=>console.log(message))
///////////////////////////////////////////////////////////////////////////////////////////

How to return function from other functions?
............................................


function increment() {

    // let inner= function(){
    //     console.log('inside increment')
    // };
    // return inner;
    return function (message) {
        console.log(`Inside increment ${message}`)
    }
}

let myfunc = increment() // =>function
myfunc('Hello');

//short cut
increment()('Hai')

// let decrement = () => {
//     return message => console.log(`Inside decrement ${message}`)
// }
let decrement = () => message => console.log(`Inside decrement ${message}`)
decrement()('Hello')

///////////////////////////////////////////////////////////////////////////////////////////
3.javascript object based programming

What is Object oriented Programming and Principles:
..................................................
 
OO Principles:

1.Abstraction
2.Encapsulation
3.Typing
     ->Polymorphism
4.Modularity
    ->packages
5.Hierachy
   -is-a : inheritance
   -has-a
-------------------
6.Concurrency

7.Persistency

if any pl follows first principle, those languages are called object oriented pl.

if any language does not implement 5 principles fully, or partially implements those
languages are called as "Object Based Programming language"

//////////////////////////////////////////////////////////////////////////////////////////

What is Object?

  Memory, having state and behaviour.

How do you create object?

In classical object oriented pl, class is fundamental unit to create object.

In javascript by default no classes : class free object based language, in es 6 , who 
added class syntax.

In javascript how to create objects?

Patterns:

1.constructor pattern
  ->functions
  ->es 6 class
2.literal pattern
  -no class,no function.

Object charactertics:

1.state : data: instance variables
2.indentity  : data :	 instance variable
3.behaviour : methods

how to declare instance variables and methods?

 ->this keyword


function as object template:

Coding standards:

1.if function is going to hold logic then function name should be
  verb or verbNoun
  add() , calculateInterest()

2.if function is going to hold object data, function name should be
  Noun
  Employee,Customer,Invoice,Order,Product....


//Object template : class
function Employee() {
    //instance variables
    this.id = 1;
    this.firstName = 'Subramanian'
    this.lastName = 'Murugan'
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };
}

//object creation
let emp = new Employee();
//access object properties:variables and methods
console.log(`Id ${emp.id}`);
console.log(`Name ${emp.firstName} ${emp.lastName}`);
console.log(`Salary ${emp.calculateSalary()}`);

here emp : it is just variable we call as reference variable
let is keyword
new is keyword to create object
Employee() -> function call with respect to Object : constructor call.


ES 6 classes:

/Syntax Sugar for function object template : class
class Customer {
    //instance variables
    id = 1;
    firstName = 'Subramanian'
    lastName = 'Murugan'
    //methods
    calculateInvoice() {
        return 1000
    }
    calculateGST = () => 1000;
}
let cust = new Customer();
//access object properties:variables and methods
console.log(`Id ${cust.id}`);
console.log(`Name ${cust.firstName} ${cust.lastName}`);
console.log(`Invoice ${cust.calculateInvoice()} ${cust.calculateGST()}`)


Literal pattern:

let product = {
    id: 1,
    name: 'Iphone',
    price: 10000,
    qty: 100,
    //methods
    calculateQty: function () {
        return 10 * 90;
    },
    calculateGST() {
        return 10;
    },
    calculateStock : () => 1000
};

console.log(`Product info`)
console.log(`Id ${product.id}`);
console.log(`name ${product.name}`);
console.log(`price ${product.price}`);
console.log(`qty ${product.qty}`);
console.log(`Stock ${product.calculateStock()}`);

///////////////////////////////////////////////////////////////////////////////////////////

How to initalize state?

state can be initalized in three ways

1.direct /hardcoded way
2.after object creation
3.during object creation.



1.direct /hardcoded way

function Employee() {
    //instance variables
    this.id = 1;
    this.firstName = 'Subramanian'
    this.lastName = 'Murugan'
 }
class Customer {
    //instance variables
    id = 1;
    firstName = 'Subramanian'
    lastName = 'Murugan'
}

let product = {
    id: 1,
    name: 'Iphone',
    price: 10000,
    qty: 100,
};


2.after object creation
//Object template : class :es 5
function Employee() {
    //instance variables
    this.id = 1;
    this.firstName = 'Subramanian'
    this.lastName = 'Murugan'
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };
}

//object creation
let emp = new Employee();
//initalize the object properties after object creation

emp.id =100;
emp.firstName = 'Srisha'
emp.lastName = 'Subramanian';


//access object properties:variables and methods
console.log(`Id ${emp.id}`);
console.log(`Name ${emp.firstName} ${emp.lastName}`);
console.log(`Salary ${emp.calculateSalary()}`);

class Customer {
    //instance variables
    id = 1;
    firstName = 'Subramanian'
    lastName = 'Murugan'
    //methods
    calculateInvoice() {
        return 1000
    }
    calculateGST = () => 1000;
}
let cust = new Customer();

//initalize the object properties after object creation
cust.id =9999;
cust.firstName ='Ram';
//access object properties:variables and methods
console.log(`Id ${cust.id}`);
console.log(`Name ${cust.firstName} ${cust.lastName}`);
console.log(`Invoice ${cust.calculateInvoice()} ${cust.calculateGST()}`)

let product = {
    id: 1,
    name: 'Iphone',
    price: 10000,
    qty: 100,
    //methods
    calculateQty: function () {
        return 10 * 90;
    },
    calculateGST() {
        return 10;
    },
    calculateStock : () => 1000
};

console.log(`Product info`)
product.id =99999;
product.name ='Lenvo Think Pad',
product.qty =90;


console.log(`Id ${product.id}`);
console.log(`name ${product.name}`);
console.log(`price ${product.price}`);
console.log(`qty ${product.qty}`);
console.log(`Stock ${product.calculateStock()}`);

3.during object creation : constructor over loading

//Object template : class :es 5
function Employee(id = 1, firstName = 'Subramanian', lastName = 'Murugan') {
    //instance variables
    this.id = id;
    this.firstName = firstName
    this.lastName = lastName
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };
}

//object creation

let emp = new Employee(1, 'Subramanian', 'Murugan');

//access object properties:variables and methods
console.log(`Id ${emp.id}`);
console.log(`Name ${emp.firstName} ${emp.lastName}`);
console.log(`Salary ${emp.calculateSalary()}`);

class Customer {
    //instance variables
    constructor(id = 1, firstName = 'Subramanian', lastName = 'Murugan') {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName
    }

    //methods
    calculateInvoice() {
        return 1000
    }
    calculateGST = () => 1000;
}
let cust = new Customer(1, 'Subramanian', 'Murugan');
//access object properties:variables and methods
console.log(`Id ${cust.id}`);
console.log(`Name ${cust.firstName} ${cust.lastName}`);
console.log(`Invoice ${cust.calculateInvoice()} ${cust.calculateGST()}`)

////////////////////////////////////////////////////////////////////////////////////////////

Hierachy: Object Relation ship

1.is-a 
2.has-a 

IS-A : Inheritance

inheritance in es 5 , so complex: proto types:
 https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance

is-a in es 6 : looks like java.

inheritance objective : code sharing in parent and child relationship.


super keyword


class Account {
    constructor(accountId) {
        console.log('Account class')
        this.accountId = accountId;
    }
    withdraw(){
        console.log('withdraw in account')
    }
}
class SavingsAccount extends Account {
    constructor(accountId) {
        super(accountId)
        console.log('SavingsAccount class')
    }
    //Redefining: not overriding
    withdraw(){
        super.withdraw()
        console.log('withdraw in SavingsAccount')
    }
}

//object creation
let account = new SavingsAccount(233);
console.log(account.accountId)
account.withdraw();

//////////////////////////////////////////////////////////////////////////////////////////

HAS-A : Dependency Injection:
..............................

done through only constructor.


//using functions
/**function Product(pid = 'P001', name = 'Iphone') {
    this.pid = pid;
    this.name = name;
}
function Order(orderId = 'A001', product = new Product()) {
    this.orderId = orderId;
    //HAS-A
    this.product = product;
}**/
//using classes
class Product {
    constructor(pid = 'P001', name = 'Iphone') {
        this.pid = pid;
        this.name = name;
    }
}
class Order {
    constructor(orderId = 'A001', product = new Product()) {
        this.orderId = orderId;
        //HAS-A
        this.product = product;
    }
}
//create object with dependencies

let product = new Product();
let order = null;

order = new Order();
console.log(`OrderId ${order.orderId} ${order.product.pid} ${order.product.name}`)

order = new Order('B002', product);
console.log(`OrderId ${order.orderId} ${order.product.pid} ${order.product.name}`)

order = new Order('B002', new Product('P8880', 'Lenvo Think Pad'));
console.log(`OrderId ${order.orderId} ${order.product.pid} ${order.product.name}`)



//has-a with literal objects: nested object

let locationInfo = {
    country: {
        countryName: 'INdia',
        state: {
            stname: 'Tamil Name',
            district: {
                name: 'Coimbatore'
            }
        }
    }
}
console.log(locationInfo.country.state.district.name)

////////////////////////////////////////////////////////////////////////////////////////////

Object internal structure:

ASYNC programming

scope chain

What is async/sync  programming?

Sync programming : sequential execution


Javascript engine archiecture : V8


What is javascript engine/runtime?

 It is program written in c / c++ /any language.
 v8 is c++ program written by google, used inside chrome and nodejs

Program  : collection of instructions

Types of Program:

1.passive program
   The program which is not in ram or which is in hard disk or the program which is not accessed by CPU.

2.Active program
  The program which is in ram, which is accssed by cpu :  Process.

Process: Program in execution

eg:

 v8 which is hard disk
  when you run/execute
  v8 is moved from harddisk to ram :  Process.


Note: Any process on any os, has structure : process layout / memory layout,
  any thing if you move on ram, will have common structure.


Process layout:

1.heap
2.stack
3.Program data



source code : index.js

 Steps 

0.Loading

    The process of reading source code from local disk or from remote machine via networks

1.compilation
   Javascript engine has in built compiler(Parser-Lexical parser)

compiler ;
 Hello.java ---javac ---- Hello.class(assembly)-----feed into runtime--->Exection
 
Parser:
 index.js----parser--->breaks javascript into string tree--->feed into runtime---> convert
 tree into assembly instruction--->execution


2.Execution
 tree into assembly instruction--->execution
 memory allocation happens for our code.


How execution begins?

 Any language , execution begins from main method.
 
Does js has main method?
  
  Yes!, which is supplied by runtime.



index.js

function sayHello(){
     console.log('hello')
}
function sayHai(){
  console.log('hai');
}

sayHello();
sayHai();
   |

 parser
   |

 parsed program
   |
 Execution
   |
  main function
   |
 sayHello();---->FUNCTION call should be moved to RAM(MEMORY ALLOCATION FOR function).

Note: if you allocate memory, os will maintain structure.

Where is function is allocated? and what is its structure?

 Function memory is allocated inside "STACK"

function  invocation means, we are pushing function into stack.

 add()------->push---into--stack ------>stack will allocate memory----"Stack Frame"

Stack frame:

 contains
 local variables
 return address

once frame is completed its operation, then will be removed from main memory.

all functions are pushed and pop sequencially : Sync Programming.


Threads:
 What is thread?

  A stack frame is called "thread".


If you are running more than one stack frame at the same time, we call "Multi threading".

Yes ,we can have multi threading :Concurrency.

Java and other languages support multi threading

Javascript engine never support multi threading. only one frame only we can run.: Single Threaded.

//sync

function add(){
   let result = 10 + 10;
}

function sayHello(){
     console.log('hello')
}
function sayHai(){
  console.log('hai');
}

add();//---pushed into stack--frame is created--running-completed
sayHello();//---pushed into stack--frame is created--running-completed
sayHai();//---pushed into stack--frame is created--running-completed



Use case : what if a frame is running long long time. 
  eg: 
   a function which connects network socket, getting 1 million data, fromating data.

during that time, what will happen to rest of the Program?

       "Blocking State" : Application will be blocked until, the frame is removed memory.

Lets imagine , you have executed js code inside browser, one function halts the entire browser
to continue.


What is the solution js offers inside of multi threading?

 Yes! : Async Programming : Another way of achiving concurrency.


What is node js?
       NonBlocking,Async Platform 



NonBlocking/Async/  Architecture:

 This is not only for node js 

 Async architecture is designed based on one design pattern "Reactor Design Pattern"


 1. worker - thread model
   The main process (Node/Browser)never creates stack frame(thread) rather than it will
  move the control to os kernal space.

 2.Events - Event Driven Programming
    Signal : completed,connected,closed......

 3.Handler function : callbacks
    The function which has been assigned for handling results.

 4.Event Queue(Task Queue)
    It is data structure which has completed job references in the form of functions
    - callback functions

 5.Event loop
    It is program which keeps on checking the queue whether any message should be
   processed : for what , in order to send results back to clients.

 Event loop can push callbacks into stack only if "stack is empty"
   
..........................................................................................

 api---push--javascript engine--stack----delagate to os kernal--- keeps on runnning on os kernal-- once done--kernal gives signal to javascript engine--- queue---event loop process the first message --if stack is empty--push that handler function to stack---stack will process the frame-result is returned to client.

/////////////////////////////////////////////////////////////////////////////////////////////

Async Programming and implemenation:
....................................

Note: dont create frames for any complex task.


Rules /Steps:

1.any async operation must be handed to libuv(Which is low level c program bundled with node distribution).
  lets say add function can it be async ?
   no: add has no eq low level api.

What are low level apis?

 Browser:
    timers
 setTimeout
 xhr: ajax : network api
 .....

 Node :
   timers
  setTimeout   
  .....

2.function should be passed as parameter : callbacks : Queue Message

............................................................................................

Progamming Implementation:

1.callback pattern
2.Promise
3.async await
4.Generators   



callbacks:

1.timers



The async code:

//Async implementation Using timer
function sayGreeter(handler) {
 //Delegate to kernal /os
 setTimeout(function(){
     handler();
 },1000);
}

function add(a, b) {
    return a + b;
}

sayGreeter(function(){
    console.log(' i wil be called late')
});//pushed into stack--settimeout---delegate to os---timer is 
 //ticking--|control is released starts execution next line --timeout----
   //--->signal "wake up"---node stores message in the event queue--loop--pick up message from
// event queue-- check whether stack is empty----push that handler into stack--display message
 //"i will be called late"
console.log(add(10,10));

//////////////////////////////////////////////////////////////////////////////////////////////

Callbacks:

  call - invoke
  back - future

callback pattern is core pattern for async programming.

callback programming and its complexcity ::"Callback hell"


Objective:
  "The result(output) of one async operation , will be input to the next operation"

//callback hell
const getUser = (success, failure) => {
    //fake data
    let user = {
        id: 1,
        name: 'admin',
        password: 'admin'
    };
    //let user = null;
    if (user) {
        setTimeout(() => success(user), 1000);
    } else {
        setTimeout(() => failure({ err: 'User Not found' }))
    }
};

const login = (user, success, failure) => {
    //biz logic
    if (user.name === 'admin') {
        setTimeout(() => {
            success({ status: 'Login Success' })
        })
    } else {
        setTimeout(() => {
            failure({ status: 'Login failed' })
        })
    }
};

//two callback functions
//getUser(user => console.log(user), err => console.log(err));

//with input to login functon
getUser(user =>
    login(user, authInfo => console.log(authInfo), err => console.log(err)),
    err => console.log(err));



Questions:

1.Whether this is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

  "No" : This is what we call as "Callback hell".

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

callback is other wise called as doom of pyrbid.

///////////////////////////////////////////////////////////////////////////////////////////

How to write better callback programming? or How to avoid callback hell?


In 2005, JQUERY team started with working complex callback patterns, they found callback
hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".


Promise is design pattern which hides complexity of callback patterns


SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

2012 E6 Commit introduced Promise as Object in javascript

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async implementations.

Promise Implemenation:

1. Create Promise Object from Promise contructor
2. Create PRomise object from factory apis 

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
4.resolve
5.reject
6.all

//promise design pattern using ES 6 Promise Object.

//Promise is by default async: you need not use timer.

function getPromise() {
    //Promise witout constructor
    return Promise.resolve('done'); // Promise Object
    // return Promise.reject('something went wrong')
}

// let result = getPromise();
// result.then(res => console.log(res));
// result.catch(err => console.log(err));
// result.finally(() => console.log('finally'))

//code refactoring using builder /command chain pattern.

console.log('start')
getPromise()
    .then(res => console.log(res))
    .catch(err => console.log(err))
    .finally(() => console.log('finally'));
console.log('end')


//Complex Callback pattens using promise

/**
const getUser = () => {
    let fakeUser = {
        id: 1,
        name: 'admin',
        password: 'admin'
    };
    if (fakeUser) {
        return Promise.resolve(fakeUser);
    } else {
        return Promise.reject({
            err: 'No User found'
        });
    }
};
**/
const getUser = () => {
    return new Promise((resolve, reject) => {
        let fakeUser = {
            id: 1,
            name: 'admin',
            password: 'admin'
        };
        if (fakeUser) {
            setTimeout(() => {
                resolve(fakeUser)
            }, 2000);
        } else {
            setTimeout(() => {
                reject({
                    err: 'User not Available'
                })
            }, 2000);
        }
    });
};

const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(() => resolve({
                loginsuccess: 'valid User'
            }), 1000);
        } else {
            setTimeout(() => reject({
                err: 'Invaild User',
                code: 400,
            }), 1000);
        }
    });
}

// getUser()
//     .then(user => console.log(user))
//     .catch(err => console.log(err))
//     .finally(() => console.log('finally'))

getUser()
    .then(user => login(user))
    .then(() => console.log('login Success'))
    .catch(err => {
        console.log(err)
    })
    .finally(() => console.log('async operation is done'))

console.log('going on')

///////////////////////////////////////////////////////////////////////////////////////////

Promise has limitions;
......................

1.Promise is still  complex when you start scalling complex async operations.

2.Which is not readable ,which uses lot of then, catch blocks

In order to write even simple complex async work flows ES 7 introduced
a concept called "async await" keywords


 It is simplest pattern of Promises.
 It is promise driven only.

 "Sync style of Async Code" 


async key must be used with function declaration.
await is used to pause async calls


async function:

by default which returns promise object what ever you return.


//async await

async function sayGreeter() {
    return "Welcome"; //Promise.resolve("Welcome")
}
console.log('start')
sayGreeter().then(result => console.log(result));
console.log('end')

async function getCounter() {
    return Promise.resolve(10);
}
getCounter().then(result => console.log(result));


async function startFlow() {
    //promise
    try {
        let fakeUser = {
            name: 'subramanain'
        }
        //let fakeUser;
        let promise = fakeUser ? Promise.resolve(fakeUser) : Promise.reject({
            err: 'Something went wrong'
        });
        let result = await promise; //await keyword passes the current 
        //execution in background ,once success , it result result
        console.log(result);
    } catch (err) {
        console.log(err);
    }
}
startFlow()

///////////////////////////////////////////////////////////////////////////////////////

Conculssion:
 callback===>promise===>async await.
 Generators,Iterators: refer
..............................................................................................

What is node js?

Node.js is javascript runtime built on top of Google V8 JAVASCRIPT Engine.


Why node was created?

Ryan Dahl who created NODE JS for building IO Non blocking application using java script language.

Javascript language was invented for DOM(web document) programming only.

JS has no any IO API like other java,c,c++

IO is part of every pl who carries blocking operations  for long time.

eg:
 if y using java, java uses an io lib to read /write data in files in disk or in network(servlets) using jvm threading model.

Process level threads has limitations

1.deadlock
2.race conditions
3.resource utilization
etc...

Web Computing and threads:
..........................

Client-----request---http----------------WebContainer(TOMCAT)---new thread---starts req-res
						|
Client-----request---http--             (JVM+HTTPSERVER)


IO : READ + WRITE 

NONBLOCKING IO ;DONT BLOCK MAIN PROCESS FOR IO OPERATIONS.

 "Node is nonblocking,async,event driven io platform to build large scale distributed,web,io intensive applications"

Node was born from google opensouce project called "V8".


Node Architecture:
..................
Please refer image.
............................................................................................

Session plan inside node:

1.node REPL
2.Node Application Modularity
3.npm 
4.NODE IO
   -FILE IO
   -NETWORK IO : WEB.

/////////////////////////////////////////////////////////////////////////////////////

node REPL : Read Evaluate print loop
 ->interactive command line utility.

js code can be executed on REPL mode or node file mode.

............................................................................................

without repl mode:

 >node  fileName.js

 >node folderName/fileName.js

............................................................................................

Node was created only for io intensive applications , not for browser apps.

React,Angular,JQuery => Browser specific objects

Browser specfic objects not available in node

node has all javascript objects expect browser specfic one

eg:
Math,JSON,Date,String,Number........ : ISMORPHIMSM 



In browser window is super object

In Node Process is super object : WHich prints info node itself.

............................................................................................

Modularity:

In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.ibm.cms

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/src/Customer.java

What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

 collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.
 Module design patterns came.

Modularity Design Patterns:

1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
3.CJS - Common JS
4.ES 6 Module design pattern  = amd + cjs
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS = ES 6

i can organize the code , based on these patterns, but what about runtimes?
  js runtime never suppport these patterns directly then each design pattern is lib.


 Modularity : code sharing across files .

How to share and how link?

amd : design pattern
 -require.js : loader program for amd design pattern

cjs : design pattern
  When node was released, node used cjs as in built design pattern.
 node has in built loader, so when you use node with cjs , loader is not necssary.
 

ES 6 mODULES: design pattern 
  It is introduced as part of es 6 spec.
es 6 is more popular
node wont support es 6 module directly, that means you need loader for es6 on node.
 
Popular loader : webpack.

****************************......................***************************************
COmmon js:

1.How to share code
  exports
  module.exports

2.How to link files
  require()
 
code : 

 variable declaration
 function declaration
 class declaration
 
  exports
  module.exports

////////////////////////////////////////////////////////////////////////////////////////////

Javascript objects:

Javascript objects are allocated in heap memory.

Object mememory layout.

Object in javascript is "Dictionary-Map-Hashtable" : key: value

Object Augmentation :

 During runtime, object properties can be added,deleted,updated,iterated.

//Adding new property during runtime.

// function Employee(){
//   this.id =1;
// }
// let emp = new Employee();

let emp = {
    id:1
}

//Add new property
emp.name = 'Subramanian'
emp.salary =9000;

//update existing property
emp.name = 'Ram'

//delete existing property
delete emp.salary

//iterate
for (const key in emp) {
   console.log(key,emp[key])
}

console.log(emp);

//Empty object
let map = {};
console.log(map);
map.lat =1999.89
console.log(map);

module.exports



class Customer {
    constructor(){
        console.log('Customer class')
    }
}

module.exports = Customer;

const result = require('./greeter')
const Customer = require('./Customer');

console.log(`${result.message} ${result.name} ${result.sayGreet()}`);

new Customer()

exports vs module.exports

exports returns an object in which you can pack all code
module.exports returns the code as it is.

//////////////////////////////////////////////////////////////////////////////////////////

Object destrucing: ES 6 

//object destructuring : breaking the object properties


// function getEmployee(emp) {

//     const { id, name, salary, department } = emp;

//     //console.log(`Id ${emp.id} name : ${emp.name} salary ${emp.salary} ${emp.department}`)
//     console.log(`Id ${id} name : ${name} salary ${salary} ${department}`)
// }

// const getEmployee = emp => {
//     const { id, name, salary, department } = emp;
//     console.log(`Id ${id} name : ${name} salary ${salary} ${department}`)
// }
const getEmployee = ({ id, name, salary, department }) => 
 console.log(`Id ${id} name : ${name} salary ${salary} ${department}`)


getEmployee({
    id: 1,
    name: 'Subramanian',
    salary: 2000,
    department: 'Training'
});

//const result = require('./greeter')
const { message, name, sayGreet } = require('./greeter')
const Customer = require('./Customer');

//console.log(`${result.message} ${result.name} ${result.sayGreet()}`);
console.log(`${message} ${name} ${sayGreet()}`);
new Customer()

/////////////////////////////////////////////////////////////////////////////////////////////

node application:

collection files and code.

node modules:

 File which contains javascript code, that can be distributed.

Types of node modules:

1.Node in built module
2.Node third party module



1.Node in built module

1.os
 Operating system releated features.


const os = require('os')

console.log(os.cpus());
console.log(os.arch())


points:

 require('os') vs require('./greeter');
                     
without ./ means, node runtime uses env settings to lookup js files automatically
./ means , lookup js files in the current dir.


how node look up js files?

node will look up files in this order

  project-folder
             ---node_modules	
			---not present
				 |
				node installation folder(c drive)
					|
					node_modules
						|
						 present : load those files
					else
					  - throw errors.



Error:
internal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osggg'
Require stack:
- C:\session\mynode-apps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\mynode-apps\src\index.js:2:12)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\mynode-apps\\src\\index.js'[39m ]


///////////////////////////////////////////////////////////////////////////////////////////

How to write event driven programming using module called "Event Emitter".

 Node is 100% event driven platform,

Programs are communicating with each other by sending signals.

node provides in built module called "events"

There are Actors:

 1.Producer
        send signals and data

 2.Listener/subscriber
     who have registered to listen signal , and for data.
    callback function /handler function.


 //event driven programming

//event driven programming

const EventEmitter = require('events');

//eventEmitter Object
let events = new EventEmitter();

//Subscriber
events.on('wakeup', function (data) {
    console.log(`wake up signal got : ${data}`)
});

//Producer
events.emit('wakeup', 'Hello Good Evening');
events.emit('wakeup', 'Hello Getting late');

/////////////////////////////////////////////////////////////////////////////////////////

//make inventory as event driven
class Inventory extends EventEmitter {
    constructor() {
        super();

        //subscribe events
        this.on('increment', function (stock) {
            //biz logic
            console.log(`Stock has been incremented ${stock}`);
        })

        this.on('decrement', function (stock) {
            console.log(`Stock has been decremented ${stock}`);
        })

    }
    //biz methods
    incrementStock(stock = 1) {
        this.emit('increment', stock);
    }
    decrementStock(stock = 1) {
        this.emit('decrement', stock);
    }
}

let inv = new Inventory();
inv.incrementStock(100);
inv.decrementStock(10);
////////////////////////////////////////////////////////////////////////////////////////////

Node and IO:

Node is used to build non block io.

 Node initallly desinged for non blocking.

Does node support blocking io?
  Yes!
Blocking io is very danagerous.
  but still node supports, dont unnecessarly use blocking io code in app.

How node supports blocking io?
  Via "Thread Pools".
  
Types of IO

1.fs io
2.network io
  -http : web apps



Use case :non blocking fs io 

const fs = require('fs');

const fileName = './src/info.txt';
const config = {
    encoding: 'UTF-8'
};

console.log('start')
fs.readFile(fileName, config, function (err, data) {
    //handle error
    if (err) throw err;
    console.log(data);
});
//readFile---stack---will communicate--libuv---readFile api(c)---os kernal--assigns thread-->
//start reading file---once file read operation is completd---emits signal-->libvu stores
//handler function inside queue---event loop--->checks whether v8 stack empty--->push handler
//function -- to print data, which was already read.
console.log('end');

Use case : Write file using nonblocking.

const fs = require('fs');
//
//write file
const writeFilepath = './src/info-copy.txt';

const data = 'This is node IO file!';

const config = {
    encoding: 'UTF-8'
};

console.log('start')

fs.writeFile(writeFilepath, data, config, function (err) {
    if (err) throw err;
    console.info(`The file ${writeFilepath} has been written!`)
});
console.log('end')

////////////////////////////////////////////////////////////////////////////////////////

Blocking IO : io operations never handled by os kernal , rather than , node(libuv)
thread pool is used.

Note:
1.Dont use blocking io apis for big files
2.Dont use blocking io apis in network applications.
3.Node supports only disk file io in blocking mode, not network apis

Node blocking io Operations:
.........................

fs.readFileSync()
fs.writeFileSync()


Use case : Blocking IO USING fs

const fs = require('fs');


const filePath = './src/info.txt';
const config = {
      encoding: 'UTF-8'
}
console.log('start');
const data = fs.readFileSync(filePath, config);
console.log(data);
console.log('end')


